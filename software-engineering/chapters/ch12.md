## Chapter 12: Software Design

### Fundamental Concepts
- **Software Design Definition**: The process of decomposing a system into constituent parts to manage complexity, serving as the blueprint for construction.
- **Wicked Problem Nature**: Software design is a "wicked problem" because it has no definitive formulation, no "stopping rule" for perfection, and solutions are judged as "good or bad" (trade-offs) rather than "true or false."
- **Information Hiding**: The most critical design principle. Each module should hide a "secret" (a specific design decision) from others to ensure that changes to that decision do not propagate.
- **Abstraction**: Concentrating on essential features while ignoring irrelevant details to reduce cognitive load.
- **Procedural Abstraction**: Naming a sequence of actions (verbs) to denote a task without specifying the internal steps.
- **Data Abstraction**: Defining data types by their objects and operations (nouns), hiding the internal representation and state.

### Cohesion: Internal Module Strength
*Ranked from weakest (avoid) to strongest (preferred):*
- **Coincidental Cohesion**: Elements grouped haphazardly with no meaningful relationship.
- **Logical Cohesion**: Elements perform similar categories of tasks but are otherwise unrelated.
- **Temporal Cohesion**: Elements grouped because they are activated at the same time.
- **Procedural Cohesion**: Elements executed in a specific order to accomplish a broader task.
- **Communicational Cohesion**: Elements operate on the same set of external data.
- **Sequential Cohesion**: Output of one element serves as the input to the next.
- **Functional Cohesion**: All elements contribute to one single, well-defined function.
- **Data Cohesion**: The strongest form; encapsulating an abstract data type where all operations relate to that data structure.

### Coupling: Inter-Module Connectivity
*Ranked from tightest (dangerous) to loosest (preferred):*
- **Content Coupling**: One module modifies another's internal data or branches into its middle; extreme fragility.
- **Common Coupling**: Modules share global data or variables; leads to hard-to-trace side effects.
- **External Coupling**: Modules communicate via external media such as files or protocols.
- **Control Coupling**: One module passes flags to direct the internal logic of another.
- **Stamp Coupling**: Passing complex data structures when only specific fields are needed.
- **Data Coupling**: The ideal form; passing only simple, necessary data items.

### Complexity and Diagnostic Metrics
- **McCabe's Cyclomatic Complexity**: Measures linearly independent paths through a module (Predicates + 1). Values over 10 indicate a routine that should be refactored.
- **Weighted Methods per Class (WMC)**: Sum of complexity of all methods in a class; high WMC indicates high maintenance effort.
- **Depth of Inheritance Tree (DIT)**: Distance from root; deep trees increase complexity and make tracing behavior difficult.
- **Number of Children (NOC)**: Count of immediate subclasses; high NOC means high impact if the base class changes.
- **Coupling Between Object Classes (CBO)**: Count of other classes a class is coupled to; high CBO reduces reuse.
- **Response For a Class (RFC)**: Number of methods executable in response to a message; measures communication complexity.
- **Lack of Cohesion (LCOM)**: Measures disjoint method sets within a class; high LCOM suggests the class should be split.

### Design Patterns and Antipatterns
- **Design Patterns**: Recurring, proven solutions to general problems (e.g., Singleton, Factory, MVC, Proxy).
- **The Blob / God Class**: A single class centralizing too much responsibility, making the system fragile and hard to understand.
- **Lava Flow**: Retaining dead or obsolete code out of fear that removing it will break the system.
- **Golden Hammer**: Obsessive use of a single tool or pattern for every problem, regardless of fit.

### Design Heuristics
- **Law of Demeter**: A method should only call methods on its own class, its parameters, or objects it creates. Avoid train wrecks like `a.getB().getC().doAction()`.
- **Favor Composition over Inheritance**: Use object composition for polymorphic behavior rather than deep, rigid inheritance hierarchies.
- **Maximize Functional Cohesion**: If a component's description requires the word "and," it likely needs splitting.
- **Encapsulate Change**: Identify the aspects most likely to change (APIs, schemas, formats) and hide them behind stable interfaces.
- **Small Interfaces**: Keep interfaces focused and minimal; avoid "Swiss Army Knife" interfaces.
