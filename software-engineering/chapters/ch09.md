## Chapter 9: Requirements Understanding and Specification

### Types of Requirements
*   **Functional Requirements:** Statements of services the system should provide, how it should react to particular inputs, and how it should behave in particular situations.
*   **Non-Functional Requirements (NFRs):** Constraints on the services or functions offered by the system, such as timing constraints, development process constraints, and standards (e.g., performance, security, reliability).
*   **Domain Requirements:** Requirements that come from the operating domain rather than from specific user needs (e.g., legal regulations or physical constants).

### The "Seven Sins" of Natural Language
When interpreting prompts, tickets, or documentation, watch for these common linguistic pitfalls:
*   **Noise:** Information that does not contribute to the specification (e.g., "The system should be user-friendly and modern").
*   **Silence:** The absence of a feature essential to the system's operation (incomplete specifications).
*   **Overspecification:** Defining the "how" (implementation details) instead of the "what" (the requirement).
*   **Contradiction:** Two or more requirements that cannot be satisfied simultaneously.
*   **Ambiguity:** Statements that allow for multiple valid but conflicting interpretations.
*   **Forward Reference:** Referring to a feature or entity that has not yet been defined or explained.
*   **Wishful Thinking:** Defining a requirement that cannot be realistically satisfied or verified (e.g., "The system shall never crash").

### Specification Quality Attributes
A high-quality requirement or specification should be:
*   **Correct:** Accurately reflects the stakeholder's needs.
*   **Unambiguous:** Has only one possible interpretation.
*   **Complete:** Includes all necessary information to implement the requirement.
*   **Consistent:** Does not conflict with other requirements.
*   **Ranked for Importance:** Its priority relative to other requirements is clear.
*   **Verifiable:** There exists a finite, cost-effective process to check if the implementation meets the requirement.
*   **Traceable:** Its origin is clear, and its implementation can be tracked.

### Verifiability of Non-Functional Requirements
*   NFRs are often stated in vague, subjective terms (e.g., "The system should be fast").
*   **The Verifiability Rule:** To be actionable, an NFR must be translated into a quantitative statement using a specific metric.
*   **Example (Performance):** "The system shall respond to 95% of queries within 2.0 seconds" instead of "The system must respond quickly."
*   **Example (Reliability):** "The system shall have a Mean Time To Failure (MTTF) of at least 1,000 hours" instead of "The system should rarely fail."

### Prioritization via MoSCoW
*   **Must have:** Critical requirements without which the system or task is considered a failure.
*   **Should have:** Important requirements that should be included if possible, but are not vital.
*   **Could have:** Desirable requirements that can be omitted if time or resources are limited.
*   **Won't have:** Requirements explicitly excluded from the current scope or iteration.

### Validation vs. Verification
*   **Validation:** "Are we building the right product?" Ensuring the requirements actually meet the user's intent and needs.
*   **Verification:** "Are we building the product right?" Ensuring the software conforms to the written specification.

### Traceability
*   **Backward Traceability:** Linking a requirement back to its source (e.g., the original issue or stakeholder request).
*   **Forward Traceability:** Linking a requirement to the specific code modules, documentation, and test cases created to satisfy it.
*   **Impact Analysis:** Traceability allows agents to understand which parts of the system are affected when a requirement changes, preventing regression errors.
