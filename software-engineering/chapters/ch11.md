## Chapter 11: Software Architecture

### Core Concepts
*   **Architecture Definition:** Software architecture consists of the set of principal design decisions about a system, defining its structure, components, and the relationships between them.
*   **The Bridge:** Architecture serves as the critical bridge between abstract requirements and concrete implementation; if this bridge is weak, the system will fail regardless of code quality.
*   **Abstraction Tool:** It provides a way to manage complexity by suppressing implementation details and focusing on high-level interactions and system-wide properties.
*   **Communication Vehicle:** The architecture provides a common language for stakeholders to discuss the system's constraints and goals.
*   **Architectural Drivers:** Architecture is primarily shaped by Quality Attributes (Non-Functional Requirements) rather than functionality; functionality is often "orthogonal" to the architecture.
*   **Quality Attribute Trade-offs:** You cannot optimize for all qualities simultaneously; a decision to increase security often decreases performance, and increasing modifiability may increase complexity.
*   **Scenarios:** Quality attributes should be defined via concrete scenarios (stimulus, environment, response) to make them measurable and testable.
*   **Utility Tree:** A tool to prioritize quality attribute scenarios by mapping them to business value and technical risk, ensuring the architecture focuses on the most critical drivers.

### Architectural Views
*   **Viewpoints vs. Views:** A viewpoint defines the conventions for constructing a view; a view is the actual representation of the system from that perspective.
*   **The 4+1 View Model:** A framework to describe architecture using multiple concurrent views:
*   **Logical View:** Focuses on functional requirementsâ€”what the system does.
*   **Process View:** Addresses concurrency, distribution, system integrity, and fault tolerance.
*   **Development View:** Describes the software's static organization (modules, libraries, sub-systems).
*   **Physical (Deployment) View:** Maps software components onto hardware, focusing on distribution and topology.
*   **Use Case View (+1):** Key scenarios that validate and illustrate how the other four views work together.

### Architectural Styles and Patterns
*   **Layered Style:** Decomposes into hierarchical levels of abstraction where each layer provides services to the one above. *Trade-off:* Clean separation and portability vs. performance overhead. *Use:* When incremental evolution and clear dependency management are needed.
*   **Pipes-and-Filters:** Processes streams of data in sequential stages where filters transform data and pipes move it. *Trade-off:* Reuse and simplicity vs. data format conversion overhead. *Use:* Data processing pipelines, compilers.
*   **Repository / Blackboard:** Multiple independent components share and operate on a large, central body of data. *Trade-off:* Simplified data sharing vs. central bottleneck risk. *Use:* Database-centric systems, AI applications.
*   **Client-Server:** Distributes services and data across a network to multiple remote consumers. *Trade-off:* Centralized management and security vs. network latency and scalability limits. *Use:* Web applications, shared resource access.
*   **Model-View-Controller (MVC):** Decouples internal data representation from presentation and input handling. *Trade-off:* High UI modifiability vs. added complexity for simple interfaces. *Use:* Interactive applications with multiple views.
*   **Event-Driven (Implicit Invocation):** Components interact without being explicitly aware of each other's existence. *Trade-off:* Extreme decoupling and extensibility vs. difficulty predicting and debugging system behavior. *Use:* GUIs, sensor networks, plug-in architectures.
*   **Abstract Data Type (ADT):** Encapsulates state and behavior into discrete objects, hiding data representations behind interfaces. *Trade-off:* Data integrity and easy data changes vs. potential coupling through method invocations. *Use:* General application development.
*   **Microservices:** Small, independent, networked services organized around business capabilities. *Trade-off:* Independent scaling and technology choices vs. significant operational and network complexity. *Use:* Large-scale systems with independent teams.

### Architectural Evaluation
*   **ATAM (Architecture Tradeoff Analysis Method):** Evaluates an architecture's fitness by uncovering risks, sensitivity points, and trade-offs.
*   **Sensitivity Point:** An architectural decision critical to achieving a specific quality attribute (e.g., buffer size affects latency).
*   **Trade-off Point:** An architectural property affecting multiple quality attributes in opposing ways (e.g., encryption increases security but decreases performance).
*   **Risks and Non-Risks:** Identification of decisions that may lead to undesirable consequences (risks) or those that are well-founded (non-risks).
*   **Evaluate Early:** The cost of changing a design decision is orders of magnitude lower than changing code.

### Design Decision Documentation
*   **The "Why" Matters Most:** Documentation must focus on the rationale behind decisions, as the structure can often be inferred from the code.
*   **Decision Fragility:** Once the original architect leaves (or the agent session ends), the "why" is lost forever if not documented.
*   **Anti-Patterns in Decisions:** Record what was *not* done and why certain patterns were rejected to prevent future developers from repeating mistakes.
*   **Architecture Decision Records (ADRs):** Lightweight, version-controlled format ensuring decision context remains attached to the system's evolution.
*   **Conway's Law:** The architecture of a system is heavily influenced by the structure of the organization that creates it.
*   **Architectural Drift:** Occurs when implementation deviates from the documented architecture; must be actively monitored and corrected.
*   **Architectural Erosion:** A severe form of drift where fundamental principles are violated, leading to an unmaintainable system.
*   **Constraint Management:** Architecture is the art of managing constraints; every decision limits the space of possible future implementations.
