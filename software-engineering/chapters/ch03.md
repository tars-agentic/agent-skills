## Chapter 3: Software Process Models and Evolution

### The Landscape of Software Process Models
*   **The Purpose of Process:** A software process model provides a structured roadmap for development; agents must identify the project's model to align with its delivery cadence and documentation expectations.
*   **Waterfall Model:** A linear, sequential flow (Requirements → Design → Implementation → Verification → Maintenance). It assumes requirements are fixed and well-understood; changes late in the cycle are extremely costly.
*   **Iterative Development:** The system is built through repeated cycles (iterations), allowing developers to learn from earlier versions and refine the product.
*   **Incremental Development:** The system is partitioned into small segments that are developed and delivered piece-by-piece. This provides early value and reduces "big bang" integration risks.
*   **Prototyping:** Building a partial implementation to clarify requirements or test technical feasibility. 
*   **Throwaway Prototyping:** The prototype is used solely for discovery and then discarded; agents must avoid the temptation to "fix up" throwaway code into production systems.
*   **Evolutionary Prototyping:** The prototype is continuously refined and eventually becomes the production system; requires high discipline in code quality from the start.
*   **Spiral Model:** A risk-driven process where development cycles are determined by explicit risk assessment and mitigation at every turn.
*   **Agile Development:** A philosophy prioritizing individuals and interactions, working software, customer collaboration, and responding to change over rigid plans and tools.

### Extreme Programming (XP) and Core Practices
*   **Test-Driven Development (TDD):** The practice of writing a failing test before writing any functional code. It ensures requirements are met and provides a safety net for future changes.
*   **Continuous Integration (CI):** Merging code into a shared repository several times a day. Automated builds and tests catch integration errors immediately.
*   **Refactoring:** Improving the internal structure of code without changing its external behavior. It is essential for managing technical debt and maintaining "evolvability."
*   **Simple Design:** Implementing only what is necessary for the current requirement ("You Ain't Gonna Need It" - YAGNI). Avoid "speculative generality" that adds complexity without current value.
*   **Small Releases:** Delivering functional software in short cycles. This provides frequent feedback loops and reduces the impact of incorrect assumptions.
*   **Collective Ownership:** Any contributor can change any part of the code. Agents must maintain consistency and follow established patterns to ensure the code remains readable by others.

### Software Evolution and Lehman's Laws
*   **The Evolution Imperative:** Software is never truly "finished." It must either evolve to meet changing needs or eventually become useless.
*   **Law I: Continuing Change.** An E-type system (embedded in the real world) must be continually adapted, or it becomes progressively less satisfactory.
*   **Law II: Increasing Complexity.** As a system evolves, its complexity increases unless work is done to maintain or reduce it (via refactoring).
*   **Law III: Self-Regulation.** Global system evolution processes are robust and self-regulating, showing a characteristic consistency in their growth and effort.
*   **Law IV: Conservation of Organizational Stability.** The average effective work rate on a system is relatively constant over time, regardless of resource spikes.
*   **Law V: Conservation of Familiarity.** The amount of new content added to each release is limited by the need for stakeholders to understand and absorb the changes.
*   **Law VI: Continuing Growth.** The functional content of a system must continually increase to maintain user satisfaction over its lifetime.
*   **Law VII: Declining Quality.** The quality of a system will appear to decline unless it is rigorously adapted to its changing operational environment.
*   **Law VIII: Feedback System.** Evolution processes constitute multi-loop, multi-level feedback systems; changes in one area inevitably trigger needs in others.

### Work Classification and Maintenance Economics
*   **Progressive Work:** Effort spent on adding new features or functional enhancements that are visible to the user.
*   **Anti-regressive Work:** Effort spent on internal improvements, such as refactoring, updating dependencies, and improving documentation. 
*   **The Maintenance Trap:** If anti-regressive work is ignored, complexity grows exponentially until progressive work (new features) becomes prohibitively slow and expensive.
*   **MoSCoW Prioritization:** A technique used to manage scope within a fixed timeframe:
    *   **Must have:** Non-negotiable requirements for a successful delivery.
    *   **Should have:** Important but not vital; can be deferred if necessary.
    *   **Could have:** Desirable enhancements that are only included if time permits.
    *   **Won't have:** Agreed-upon items that will not be included in the current release.
*   **Time-boxing:** Fixing the delivery date and adjusting the scope (using MoSCoW) rather than extending the deadline.

### Software Product Lines (SPL)
*   **Product Line Concept:** A set of software systems that share a common, managed set of features. This approach enables massive reuse across a family of products.
*   **Core Assets vs. Product Specifics:** SPLs distinguish between the "platform" (core components) and "deltas" (custom logic for specific variants).
*   **Agent Responsibility in SPLs:** When modifying a product line, agents must determine if a change belongs in the shared core (affecting all variants) or a specific product delta.

### Decision Heuristic for Process Selection
*   **Requirements Stability:** Use Waterfall/Linear models for fixed, well-defined requirements; use Agile/Iterative models for volatile or exploratory requirements.
*   **Risk Profile:** Use the Spiral model or heavy prototyping for projects with high technical or market uncertainty.
*   **Feedback Cadence:** Use Agile and XP practices when the cost of a "wrong" feature is high and frequent stakeholder feedback is the primary risk mitigator.
