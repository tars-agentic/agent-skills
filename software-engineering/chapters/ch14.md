## Chapter 14: Software Maintenance, Evolution, and Technical Debt

### Maintenance Categories
*   **Corrective Maintenance:** Reactive modification to correct discovered problems (bug fixing).
*   **Adaptive Maintenance:** Modification to keep software usable in a changed environment (e.g., OS updates, cloud migrations).
*   **Perfective Maintenance:** Modification to improve performance, maintainability, or add new user requirements (functional enhancements). Represents the largest share of maintenance effort (~50%).
*   **Preventive Maintenance:** Modification to detect and correct latent faults before they become failures (reducing technical debt).

### Maintenance Models
*   **Quick-Fix Model:** Changes made directly to source code without updating design documents; fast but rapidly increases entropy.
*   **Iterative-Enhancement Model:** Maintenance treated as a cycle of discovery, design, and implementation; preserves long-term integrity.
*   **Emergency Fixes:** High-pressure corrective maintenance requiring a follow-up rehabilitation phase to align with architectural standards.

### Lehman's Laws of Software Evolution
*   **Continuing Change:** A system used in a real-world environment must change, or it becomes progressively less useful.
*   **Increasing Complexity (Entropy):** As a system evolves, its complexity increases unless work is done to maintain or reduce it.
*   **Self-Regulation:** Global evolution processes are self-regulating; distribution of measures are close to normal.
*   **Conservation of Familiarity:** Average incremental growth remains constant to ensure the system stays manageable.
*   **Conservation of Quality:** Quality will appear to decline unless rigorously maintained and adapted.
*   **Feedback System:** Evolution processes are multi-level, multi-loop feedback systems.

### Refactoring and Restructuring
*   **Restructuring:** Transforming representation at the same abstraction level while preserving external behavior.
*   **Refactoring:** Improving internal code structure through small, behavior-preserving transformations.
*   **Reverse Engineering:** Analyzing a system to identify components and relationships, creating higher-level representations.
*   **Forward Engineering:** The traditional process of moving from high-level abstractions to physical implementation.

### The Code Smells Catalog
*   **Bloaters:** Code grown too large — Long Method, Large Class, Primitive Obsession, Long Parameter List.
*   **Object-Oriented Abusers:** Poor application of OO principles — Switch Statements (where polymorphism is needed), Refused Bequest, Alternative Classes with Different Interfaces.
*   **Change Preventers:** Patterns that hinder evolution — Divergent Change (one class changed for many reasons), Shotgun Surgery (one change requiring edits across many classes).
*   **Dispensables:** Pointless, redundant code — Lazy Class, Data Class, Dead Code, Speculative Generality.
*   **Couplers:** Excessive coupling — Feature Envy, Inappropriate Intimacy, Message Chains, Middle Man.

### Maintainability Principles
*   **Anticipate Change:** Architecture should isolate volatile components from stable components.
*   **Code Minimization:** The most maintainable code is the code never written; avoid speculative generality.
*   **Design Rationale Documentation:** Capturing *why* a decision was made is more important than documenting *what* was built.
*   **Regression Testing:** A robust automated test suite is the primary prerequisite for safe maintenance and evolution.
*   **Self-Descriptive Code:** Prioritize expressive naming and clean structure over external documentation.

### Evolution Analysis and Predictors
*   **Yesterday's Weather:** The best predictor of where future changes and bugs will occur is the history of where they occurred recently in version control.
*   **Co-Change Analysis:** Files or modules that frequently change together reveal hidden logical coupling that needs refactoring.
*   **Change Impact Analysis:** Identifying the potential consequences of a change, or estimating what needs to be modified.
*   **Technical Debt Interest:** The cumulative cost of additional rework caused by choosing an easy solution now instead of a better approach that would take longer.
*   **Maintainability Index:** A composite metric (Halstead Volume, Cyclomatic Complexity, Lines of Code) used to track codebase health over time.
